\documentclass{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

\usepackage{acronym} % \ac[p], \acl[p], \acs[p], \acf[p]
\usepackage{algorithm} % \begin{algorithm} \end{algorithm}
\usepackage{algpseudocode} % \begin{algorithmic} \end{algorithmic}
\usepackage{authblk} % \affil
\usepackage[defernumbers=true, sorting=none]{biblatex}
\usepackage[inline]{enumitem} % \begin{enumerate*} \end{enumerate*}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath} % \begin{align*}
\newcommand{\removespacebelowalign}[0]{ \setlength{\belowdisplayskip}{-10pt} \setlength{\belowdisplayshortskip}{-10pt}}

\usepackage{amssymb} % \nexists

\newcommand{\commands}[1]{commands = \set{#1}}
\newcommand{\fnspec}[3]{#1: #2 \text{ : #3}}
\newcommand{\inbb}[1]{\in \mathbb{#1}}
\newcommand{\mathlist}[2]{\set{#1_i: #2}_{i \inbb{N}}}
\newcommand{\queries}[1]{queries = \set{#1}}
\newcommand{\set}[1]{\left\{#1\right\}} % set brace notation
\newcommand{\spectuple}[1]{\tuple{#1, constructor, queries, commands}}
\newcommand{\ssep}{\mid} % separator of set builder
\newcommand{\tuple}[1]{\langle #1 \rangle}

% Theorem
% ------
\usepackage{amsthm} %\newcounter{<name>}[<counter-name>]{<displayed-name>}

\newcounter{definition-counter}
\theoremstyle{definition}
\newtheorem{definition}[definition-counter]{Definition}

\newcounter{note-counter}
\theoremstyle{definition}
\newtheorem{note}[note-counter]{Note}

\newcounter{propertycounter}
\theoremstyle{definition}
\newtheorem{property}[propertycounter]{Property}
\def\propertycounterautorefname{Property}

\newcounter{specificationcounter}
\theoremstyle{definition}
\newtheorem{specification}[specificationcounter]{Specification}
\def\specificationcounterautorefname{Specification}

\usepackage{graphicx}
\usepackage{color}
\AtBeginDocument{
\definecolor{pdfurlcolor}{rgb}{0,0,0}
\definecolor{pdfcitecolor}{rgb}{0,0,0}
\definecolor{pdflinkcolor}{rgb}{0,0,0}
\definecolor{light}{gray}{.85}
\definecolor{vlight}{gray}{.95}
\definecolor{darkgreen}{rgb}{0.0, 0.2, 0.13}
}
\usepackage{hyperref}

\newcommand{\email}[1]{\href{mailto:#1}{#1}}

\usepackage[draft,inline,nomargin,index]{fixme}
\fxsetup{theme=colorsig,mode=multiuser,inlineface=\itshape,envface=\itshape}
\FXRegisterAuthor{go}{ago}{Gerald}
\FXRegisterAuthor{mn}{amn}{Matthieu}

% Acronyms
% --------
\acrodef{ADT}[ADT]{Abstract Data Type}
\acrodefplural{ADT}[ADTs]{Abstract Data Types}

\acrodef{CRDT}[CRDT]{Conflict-free Replicated Data Type}
\acrodefplural{CRDT}[CRDTs]{Conflict-free Replicated Data Types}

\acrodef{SEC}[SEC]{Strong Eventual Consistency}

% Meta-Data
% ---------

\hypersetup{pdftitle={In progress},
    pdfsubject={},
    pdfkeywords={Data replication, CRDT},
    pdfauthor={M. Nicolas, O. Perrin, G. Oster}}

%\pagestyle{empty}

\addbibresource{ref.bib}

\begin{document}
\removespacebelowalign

\title{Improving Replicated Sequences Performances}
\author{Matthieu Nicolas}
\author{Gérald Oster}
\author{Olivier Perrin}
\affil{Université de Lorraine, CNRS, Inria, LORIA, F-54500, France}
\date{}

\maketitle

\section{Introduction}

\section{Replicated Sequences}

\subsection{Sequence}

The \emph{Sequence} is an \ac{ADT} which allows to represent a list of ordered values.
Sequences are widely used in algorithms to represent collections of values where the order of the values is relevant such as strings, messages from a discussion or events from a log.
Traditionally, implementations provided by programming languages support the following specification:

\begin{specification}[Sequence]
    \begin{align*}
    &\forall V: \mathsf{Value} \ \forall S: \mathsf{Sequence} \tuple{V} \cdot \spectuple{S}\\
    &S = \mathlist{v}{V}\\
    &\fnspec{constructor}{\left( \right) \to S}{Generates and returns an empty sequence}\\
    &queries = \set{length, get}\\
    &commands = \set{insert, remove}\\
    &\fnspec{length}{S \to \mathbb{N}}{Returns the number of values contained in the sequence}\\
    &\fnspec{get}{\set{s \in S} \times \set{ n \inbb{N} \ssep n < length(s) } \to V}{Returns the value from the sequence $s$ at the index $n$}\\
    &\fnspec{insert}{\set{s \in S} \times \set{ n \inbb{N} \ssep n < length(s) } \times V \to S}{Inserts the given value into the sequence $s$ at the index $n$ and ... }\\ % returns the updated sequence}\\
    &\fnspec{remove}{\set{s \in S} \times \set{ n \inbb{N} \ssep n < length(s) } \to S}{Removes the value from the sequence $s$ at the index $n$ and returns ... }% the updated sequence}
    \end{align*}
    \label{spec:seq}
\end{specification}
\mnnote{TODO: Fixer la mise en page pour que les descriptions des fonctions ne soient pas tronquées}\\

However, this specification has been designed for a sequential execution.
Using naively this \ac{ADT} in a distributed system to replicate a sequence among nodes would result in inconsistencies, as illustrated in \autoref{fig:basic-seq-divergence}.
In this example, two nodes A and B own initially a copy of the same sequence.
Without coordinating, both of them perform an update and broadcast it to the other node.
However, applying both updates does not yield the same final state on each node.

\begin{figure}
    \centering
    \includegraphics[width=0.75\textwidth]{img/index-based-seq.pdf}
    \caption{Example of concurrent operations on an index-based sequence resulting into an inconsistency}
    \label{fig:basic-seq-divergence}
\end{figure}

This issue is a well-know problem in the domain of collaborative editing and has been an area of research for many years.
\mnnote{TODO: Ajouter des références à des papiers sur OT}
These works eventually led to new specifications of the \emph{Sequence} belonging to a new family of data types: \acfp{CRDT}. \mnnote{TODO: Ajouter référence à WOOT}

\subsection{\acfp{CRDT} \cite{shapiro:inria-00555588, shapiro_2011_crdt}}

\acfp{CRDT} are new specifications of \acp{ADT}, such as the \emph{Set} or the \emph{Sequence}.
Contrary to traditional specifications, \acp{CRDT} are designed to support natively concurrent updates.
To this end, these data types embed directly into their specification a conflict resolution mechanism.
These specifications can be followed to implement optimistically replicated data structures which ensure \acf{SEC} \cite{shapiro_2011_crdt}.

\begin{definition}[Strong Eventual Consistency]\label{def:sec}
\acf{SEC} is a consistency model which guarantees that any two nodes of the distributed system observing the same set of updates reach equivalent states, without requiring any further communications than the ones needed to broadcast the updates.
\end{definition}

These data structures are particularly suited to build highly-available large-scale distributed systems in which nodes share and update data without any coordination.

For a given \ac{ADT}, several specifications of \acp{CRDT} can be proposed.
They can be classified into three categories: State-based \acp{CRDT}, Operation-based \acp{CRDT} and Delta-based \acp{CRDT}.
State-based \acp{CRDT} are often more complex data structures than their Operation-based counterparts, but make no assumptions on the reliability of the message-passing layer.
Operation-based \acp{CRDT} are thus simpler but usually rely on a message-passing layer ensuring the exactly-once causally-ordered delivery of updates.
The third category, the Delta-based \acp{CRDT} one, was more recently proposed and draws out the best from both worlds.

To solve conflicts deterministically and ensure the convergence of all nodes, \acp{CRDT} relies on additional metadata.
In the context of Sequence \acp{CRDT}, two different approaches were proposed, each trying to minimize the overhead introduced.
The first one affixes constant-sized identifiers to each value in the sequence and uses them to represent the sequence as a linked list.
The downside of this approach is an evergrowing overhead, as it needs to keep removed values to deal with potential concurrent updates, effectively turning them into tombstones.
The second one avoids the need of tombstones by instead attaching densely-ordered identifiers to values.
It is then able to order values into the sequence by comparing their respective identifiers.
However this approach also suffers from an increasing overhead, as the size of such densely-ordered identifiers is variable and grows over time.

In this paper, we focus on Densely-identified Operation-based Sequence \acp{CRDT} and propose a renaming mechanism to reduce the metadata overhead introduced by this approach.

\subsection{Logoot \cite{WeissICDCS09}}

Logoot is an Element-wise Densely-identified Operation-based Sequence \ac{CRDT}.
Its key insight is to replace the use of mutable $indexes$ to refer to values into the sequence with immutable $positions$.
As illustrated previously in \autoref{fig:basic-seq-divergence}, in the case of traditional sequences, operations update the sequence and shift values, resulting in inconsistencies when applying several concurrent operations.
By using immutable $positions$ to refer to values, Logoot is able to define a sequence with commutative operations, suited for usages in distributed settings.

When inserting a value into the sequence, the node generates a fitting $position$ and associates it to the value.
These $positions$ fulfill several roles:

\begin{note}
    A $position$ identifies uniquely a value.
\end{note}

\begin{note}
    A $position$ embodies the intended order relation between the value and other values from the sequence.
\end{note}

% \begin{enumerate}
%     \item A $position$ identifies uniquely a value.
%     \item A $position$ embodies the intended order relation between the value and other values from the sequence.
% \end{enumerate}

To perform these roles, $positions$ have to comply to several constraints:

\begin{property}(Global Unicity)\label{prop:global-unicity}
    Nodes should not able to compute the same $position$ concurrently.
\end{property}

\begin{property}(Timeless Unicity)\label{prop:timeless-unicity}
    Nodes should not be able to associate the same $position$ to different values during the lifetime of the sequence.
\end{property}

\begin{property}(Total Order)\label{prop:total-order}
    A total order relation must exist over $positions$ so nodes can order two values given their respective $positions$.
\end{property}

\begin{property}(Dense Set)\label{prop:dense-set}
    Nodes should always be able to generate new $positions$ between two others.
\end{property}

To define $positions$ meeting these properties, Logoot first introduces \emph{LogootTuples} which are specified as in \autoref{spec:logoot-tuple}.
\emph{LogootTuples} are triples made of the following elements:
\begin{itemize}
    \item $priority$: sets the order of this tuple relatively to others, arbitrary picked by the node upon generation
    \item $id_{site}$: refers to the node's identifier, assumed to be unique
    \item $seq_{site}$: refers to the node's logical clock, which increases monotonically with local updates
\end{itemize}

\begin{specification}[LogootTuple]
    \begin{align*}
    &\forall T: \mathsf{LogootTuple} \cdot \spectuple{T}\\
    &T = \tuple{\mathbb{N}, \mathbb{I}, \mathbb{N}}\\
    &\fnspec{constructor}{\mathbb{N} \times \mathbb{I} \times \mathbb{N} \to T}{Returns a LogootTuple made of the given $priority$, $id_{site}$ and $seq_{site}$}\\
    &\queries{priority, peer, seq}\\
    &\commands{}\\
    &\fnspec{priority}{T \to \mathbb{N}}{Returns the $priority$ of the given tuple}\\
    &\fnspec{peer}{T \to \mathbb{I}}{Returns the $id_{site}$ of the given tuple}\\
    &\fnspec{seq}{T \to \mathbb{N}}{Returns the $seq_{site}$ of the given tuple}
    \end{align*}
    \label{spec:logoot-tuple}
\end{specification}

Based on this building block, Logoot defines positions as sequences of \emph{LogootTuples}, as shown in \autoref{spec:logoot-pos}.

\begin{specification}[LogootPos]
    \begin{align*}
    &\forall T: \mathsf{LogootTuple} \ \forall P: \mathsf{LogootPos} \cdot \spectuple{P}\\
    &P = \mathlist{t}{T}\\
    &\fnspec{constructor}{\mathlist{t}{T} \to P}{Returns a LogootPos made of the given tuples}\\
    &\queries{length, get, lastTuple, peer, seq, uid}\\
    &\commands{}\\
    &\fnspec{length}{P \to \mathbb{N}}{Returns the number of tuples composing the position}\\
    &\fnspec{get}{\set{p \in P} \times \set{n \inbb{N} \ssep n < length(p)} \to T}{Returns the n-th tuple of the given position}\\
    &\fnspec{lastTuple}{P \to T}{Returns the last tuple of the given position}\\
    &\fnspec{peer}{P \to \mathbb{I}}{Returns the $id_{site}$ of the last tuple of the given position}\\
    &\fnspec{seq}{P \to \mathbb{N}}{Returns the $seq_{site}$ of the last tuple of the given position}\\
    &\fnspec{uid}{P \to \tuple{\mathbb{I}, \mathbb{N}}}{Returns the unique id of the given position}
    \end{align*}
    \label{spec:logoot-pos}
\end{specification}

It allows positions to meet all the required constraints:
\begin{note}
    Given a position $p$, the couple $\tuple{peer(p), seq(p)}$ is globally and timelessly unique as:
    \begin{itemize}
        \item No other node can generate a position using the same $id_{site}$ as it is unique.
        \item No other position can be generated by the same node using the same $seq_{site}$ as it is increasing monotonically with local updates.
    \end{itemize}
\end{note}

\begin{note}
    A dense total order can be created over positions by:
    \begin{itemize}
        \item Comparing theirs tuples using the lexicographical order.
        \item Defining a special tuple, $minTuple$ such that $\forall t \in LogootTuple \cdot minTuple < t$.
        Given two positions $p1, p2$ such as $p1 < p2$, it allows any node to generate a new position $p3$ such as $p1 < p3 < p2$ by reusing the tuples of $p1$, appending $minTuple$ as many times as required and finally appending a tuple of its own creation.
    \end{itemize}
\end{note}

Relying on these positions, Logoot proposes a new specification corresponding to a replicable sequence, described in \autoref{spec:logoot-seq}.

\begin{specification}[LogootSeq]
    \begin{align*}
    &\forall P: LogootPos \ \forall V: \mathsf{Value} \ \forall S: \mathsf{LogootSeq} \tuple{V} \cdot \spectuple{S}\\
    &S = \set{\tuple{p: \mathsf{P}, v: \mathsf{V}}_i}_{i \inbb{N}}\\
    &\fnspec{constructor}{\left( \right) \to S}{Generates and returns an empty Logoot sequence}\\
    &\queries{length, getPos, generatePos}\\
    &\commands{insert, remove}\\
    &\fnspec{length}{S \to \mathbb{N}}{Returns the number of values contained in the sequence}\\
    &\fnspec{getPos}{\set{s \in S} \times \set{n \inbb{N} \ssep n < length(S)} \to P}{Returns ...}\\
    &\fnspec{generatePos}{\mathbb{I} \times \mathbb{N} \times \set{s \in S} \times \set{n \inbb{N} \ssep n < length(S)} \to P}{Returns ...}\\
    &\fnspec{insert}{S \times P \times V \to S}{Inserts the given value into the sequence using its position and returns...}\\
    &\fnspec{remove}{S \times P \to S}{Removes the value from the sequence attached to the given position and returns...}
    \end{align*}
    \label{spec:logoot-seq}
\end{specification}

Using this data type, we can replay the previous scenario while this time ensuring the correctness and convergence of the final states as illustrated in \autoref{fig:logoot-seq-convergence}.

In this scenario, node A wants to insert the value "b" between the values "a" and "c".
To this end, it generates and attaches to "b" a position greater than the position of "a", but lesser than the position of "c".
As there is plenty of room between these two positions, node A is able to generate a position of the same size embodying the intended order.
It that was not the case, node A would have to generate a position by reusing the tuple of "a" and appending to it its own tuple, resulting in a longer position.

Meanwhile, node B wants to remove the value "x" from the sequence.
To do so, it uses the position attached to this value which identifies it uniquely.

\mnnote{TODO: Trouver comment conclure cet exemple}

\begin{figure}
    \centering
        \includegraphics[width=0.75\textwidth]{img/pos-based-seq.pdf}
    \caption{The previous scenario fixed using Logoot positions instead of indexes}
    \label{fig:logoot-seq-convergence}
\end{figure}

\mnnote{TODO: Changer la figure pour utiliser des naturels comme priority, histoire d'être cohérent avec la spécification}

\subsection{LogootSplit \cite{AndreCollaborateCom2013}}

LogootSplit is a Block-wise Densely-identified Operation-based Sequence \ac{CRDT}.
Proposed by \textcite{AndreCollaborateCom2013}, its goal is to improve further the efficiency of the replicated sequence.

Indeed, it is expensive to generate and associate a new position to each value of the sequence.
To reduce the metadata overhead, the authors propose to aggregate dynamically values into blocks.
By regrouping values into blocks, LogootSplit can assign logically a position to each value, while effectively storing only the position of the first value of each block.
This shifts the cause of metadata growth from the number of values to the number of blocks.
As a block can contains an arbitrary number of values, it can lead to a significant increase of the efficiency of the data structure.

To achieve this, LogootSplit adds a new component to the tuples composing its positions, the $offset$.
This component allows to specify the offset of a value into a block.
According to this change, LogootSplit redefines the tuples that it uses as well as the positions, as shown respectively in \autoref{spec:logootsplit-tuple} and \autoref{spec:logootsplit-pos}.

\mnnote{J'aurai bien aimé avoir une abstraction unique pour les Tuples et Positions de Logoot et LogootSplit plutôt que de les redéfinir ici, mais je n'ai pas réussi à la formaliser pour le moment.}

\begin{specification}[LogootSplitTuple]
    \begin{align*}
    &\forall T: \mathsf{LogootSplitTuple} \cdot \spectuple{T}\\
    &T = \tuple{\mathbb{N}, \mathbb{I}, \mathbb{N}, \mathbb{N}}\\
    &\fnspec{constructor}{\mathbb{N} \times \mathbb{I} \times \mathbb{N} \times \mathbb{N} \to T}{Returns a LogootSplitTuple made of the given $priority$, $id_{site}$, $seq_{site}$ and $offset$}\\
    &\queries{priority, peer, seq, offset}\\
    &\commands{}\\
    &\fnspec{priority}{T \to \mathbb{N}}{Returns the $priority$ of the given tuple}\\
    &\fnspec{peer}{T \to \mathbb{I}}{Returns the $id_{site}$ of the given tuple}\\
    &\fnspec{seq}{T \to \mathbb{N}}{Returns the $seq_{site}$ of the given tuple}\\
    &\fnspec{offset}{T \to \mathbb{N}}{Returns the $offset$ of the given tuple}
    \end{align*}
    \label{spec:logootsplit-tuple}
\end{specification}

\begin{specification}[LogootSplitPos]
    \begin{align*}
    &\forall T: \mathsf{LogootSplitTuple} \ \forall P: \mathsf{LogootSplitPos} \cdot \spectuple{P}\\
    &P = \mathlist{t}{T}\\
    &\fnspec{constructor}{\mathlist{t}{T} \to P}{Returns a LogootSplitPos made of the given tuples}\\
    &\queries{length, get, lastTuple, peer, seq, offset, uid}\\
    &\commands{fromBase, concat, truncate}\\
    &\fnspec{length}{P \to \mathbb{N}}{Returns the number of tuples composing the position}\\
    &\fnspec{get}{\set{p \in P} \times \set{n \inbb{N} \ssep n < length(p)} \to T}{Returns the n-th tuple of the given position}\\
    &\fnspec{lastTuple}{P \to T}{Returns the last tuple of the given position}\\
    &\fnspec{peer}{P \to \mathbb{I}}{Returns the $id_{site}$ of the last tuple of the given position}\\
    &\fnspec{seq}{P \to \mathbb{N}}{Returns the $seq_{site}$ of the last tuple of the given position}\\
    &\fnspec{offset}{P \to \mathbb{N}}{Returns the $offset$ of the last tuple of the given position}\\
    &\fnspec{uid}{P \to \tuple{\mathbb{I}, \mathbb{N}, \mathbb{N}}}{Returns the unique id of the given position}\\
    &\fnspec{fromBase}{P \times \mathbb{N} \to P}{Returns a new position made by copying the given position and replacing its offset...}\\
    &\fnspec{concat}{P \times P \to P}{Returns a new position made by concatenating tuples from both given positions}\\
    &\fnspec{truncate}{P \times \mathbb{N} \to P \times P}{Returns a new position made by concatenating tuples from both given positions}
    \end{align*}
    \label{spec:logootsplit-pos}
\end{specification}

Based on its specification of positions, LogootSplit defines the aggregability of positions as follow:

\begin{definition}[Base of a Position]
    The base of a position corresponds to the position deprived of the offset of its last tuple.
\end{definition}

\begin{definition}[Positions Aggregability]
    Two positions are aggregable into a block if they share the same base and if their respective offsets are consecutives.
    It implies that a given block can contain only values inserted by the same node, as the positions have to share the same base thus the same peer.
\end{definition}

\mnnote{FIXME: je ne savais pas où insérer l'highlight sur le fait que les valeurs d'un bloc doivent avoir été insérées par le même noeud donc je l'ai mis dans la définition. À bouger?}

This rule to aggregate positions into blocks results into their following specification.
A block is composed of a position corresponding to the position of its first value, and of the offset of its last value.
LogootSplit can then compute the position of each value of the block by replacing the offset of the first position of the block by the offset of the value.
When inserting a new value into the sequence, LogootSplit first seeks to append or to prepend it respectively to the preceding block or to the succeeding one.
If it is not possible, LogootSplit generates and inserts a new block at the intended place.
To ensure that the positions comply with \autoref{prop:timeless-unicity}, LogootSplit keeps track of the used offsets per block to not reassign the same position to different values.

\begin{specification}[LogootSplitBlock]
    \begin{align*}
    &\forall P: \mathsf{LogootSplitPos} \ \forall B: \mathsf{LogootSplitBlock} \cdot \spectuple{B}\\
    &B = \tuple{\set{p \in P}, \set{n \inbb{N} \ssep offset(p) \leq n}}\\
    &\fnspec{constructor}{P \times \mathbb{N} \to I}{Returns a LogootSplitBlock...}\\
    &\queries{length, posBegin, posEnd, begin, end, peer, seq, uid}\\
    &\commands{}\\
    &\fnspec{length}{B \to \mathbb{N}}{Returns the number of values of the block}\\
    &\fnspec{posBegin}{B \to P}{Returns the first position of the block}\\
    &\fnspec{posEnd}{B \to P}{Returns the last position of the block}\\
    &\fnspec{begin}{B \to \mathbb{N}}{Returns the offset of posBegin}\\
    &\fnspec{end}{B \to \mathbb{N}}{Returns the offset of posEnd}\\
    &\fnspec{peer}{B \to \mathbb{I}}{Returns the peer of the positions of the given block}\\
    &\fnspec{seq}{B \to \mathbb{N}}{Returns the sequence number of the positions of the given block}\\
    &\fnspec{uid}{I \to \tuple{\mathbb{I}, \mathbb{N}}}{Returns the unique id of the given block}
    \end{align*}
    \label{spec:logootsplit-block}
\end{specification}

It is interesting to notice that, in the context of LogootSplit:
\begin{itemize}
    \item Given a position $p$, the triple $\tuple{peer(p), seq(p), offset(p)}$ identifies uniquely this position.
    \item Given a block $b$, the couple $\tuple{peer(b), seq(b)}$ identifies uniquely the base of its positions.
    \item Given a block $b$, the quadruple $\tuple{peer(b), seq(b), begin(b), end(b)}$ identifies uniquely this block.
\end{itemize}

LogootSplit proposes a new specification of the replicated sequence illustrated in \autoref{spec:logootsplit-seq}, supporting string-wise operations. An example of its behavior is shown in \autoref{fig:logootsplit-example}.

\begin{specification}[LogootSplitSeq]
    \begin{align*}
    &\forall P: LogootSplitPos \ \forall B: LogootSplitBlock \ \forall V: \mathsf{Value} \ \forall S: \mathsf{LogootSplitSeq} \tuple{V} \cdot \spectuple{S}\\
    &S = \set{\tuple{b: \mathsf{B}, \set{v_j: \mathsf{V}}_{j \inbb {N}}}_i}_{i \inbb{N}}\\
    &\fnspec{constructor}{\left( \right) \to S}{Generates and returns an empty LogootSplit sequence}\\
    &\queries{length, getBlocks, generatePos}\\
    &\commands{insert, remove}\\
    &\fnspec{length}{S \to \mathbb{N}}{Returns the number of values contained in the sequence}\\
    &\fnspec{getBlocks}{\set{s \in S} \times \set{n_1 \inbb{N} \ssep n_1 < length(S)} \times \set{n_2 \inbb{N} \ssep n_1 \leq n_2 < length(S))} \to \mathlist{b}{B}}{...}\\
    &\fnspec{generatePos}{\mathbb{I} \times \mathbb{N} \times \set{s \in S} \times \set{n \inbb{N} \ssep n < length(S)} \to P}{Returns ...}\\
    &\fnspec{insert}{S \times P \times \mathlist{v}{V} \to S}{Inserts the given values into the sequence using its position and returns...}\\
    &\fnspec{remove}{S \times \mathlist{b}{B} \to S}{Removes the values from the sequence attached to the given position...}
    \end{align*}
    \label{spec:logootsplit-seq}
\end{specification}

\begin{figure}
    \centering
        \includegraphics[width=0.6\textwidth]{img/logootsplit-seq.pdf}
    \caption{An example of replicated sequence using LogootSplit}
    \label{fig:logootsplit-example}
\end{figure}

\mnnote{TODO: Finalement, j'aurai tendance à fusionner les sections sur Logoot et LogootSplit pour ne garder que LogootSplit. Dans un premier temps, je peux introduire la notion de position en ne tenant pas compte de offset (ça m'embête juste de mettre l'exemple \autoref{fig:logoot-seq-convergence}, réadapté pour LogootSplit, sans avoir mis la spécification de la séquence au préalable). Puis je peux motiver le fait de regrouper les valeurs par blocs pour réduire l'overhead, expliquer le rôle de offset et remettre l'exemple \autoref{fig:logootsplit-example}.}

\subsection{Limits}

\begin{itemize}
    \item As shown previously, LogootSplit positions' size is not bounded in order to comply with the dense constraint.
    \item As more elements are added to the sequence, less positions of the minimum size are available to insert new elements while respecting the intended order.
    \item Thus the size of new positions tends to grow as the lifetime of the replicated sequence increases.
    \item However, the growth of the size of positions impacts negatively the performances of the application on several aspects.
    \begin{itemize}
        \item As positions attached to elements become longer, the memory overhead of the data structure increases accordingly.
        \item This also results in an increase of the bandwidth consumption, as positions have to be broadcast between nodes.
        \item Also, operations needs to compare positions, either to look for the deleted positions or to find the place to insert the ones. The longer the positions are, the slower is the processing of operations.
    \end{itemize}
    \item Additionally, the number of blocks composing the sequence tends to growth as well.
    \item It is not always possible to add newly inserted positions to existing blocks because of the rules on the generation of positions and on their aggregability.
    \item This results in the addition of new blocks to the sequence.
    \item As no mechanism to merge blocks a posteriori is provided, the resulting sequence ends up being fragmented into many blocks.
    \item This degrades as well the performances of the application, as the number of blocks increases the memory overhead of the data structure and the computation time required to browse the sequence.
    \item \mnnote{
        TODO: Illustrer ces baisses d'efficacité à l'aide de mesures :
        \\
        - Un graphe sur l'évolution du poids de la séquence par rapport au nombre d'éléments contenus en fonction du nombre d'opérations jouées préalablement
        \\
        - Un graphe sur l'évolution du temps de traitement d'une opération par rapport au nombre d'éléments contenus en fonction du nombre d'opérations jouées préalablement
    }
    \item It is thus necessary to either propose a more efficient specification of the replicated list, with a reduced growth of the overhead
    \item ... or to provide a mechanism allowing to reset the overhead of the data structure at times.
    \item The work introduced in this paper corresponds to the later approach.
\end{itemize}

\section{Overview}

\begin{itemize}
    \item We build up on top of LogootSplit
    \item To address its limitations, we introduce a renaming mechanism
    \item The purpose of this mechanism is to reassign shorter positions to each element such as all of them can be aggregated into one unique block
    \item This allows to reduce the metadata per element, the computation time required to apply next updates and also the bandwidth used to broadcast future updates
    \item \mnnote{TODO: Expliquer que toutefois le mécanisme de renommage ajoute un coût et qu'on cherche à le minimiser. Mais j'ai du mal à voir comment introduire la notion de cet overhead sans rentrer dans les détails qui en sont la source (règles de réécriture, arborescence des epochs, transformation des opérations concurrentes), que je préférerais introduire un par un dans la suite du papier}
    \item For simplicity purposes, will first present the renaming mechanism in the context of a centralised system, with only one node able to trigger the renaming mechanism
    \begin{itemize}
        \item Will describe the functioning of this initial version and discuss its limitations
    \end{itemize}
    \item Will then present a more elaborated version of the renaming mechanism, overcoming the limitations of the centralised version and allowing its use in a distributed setting
\end{itemize}

\section{Renaming in a centralised setting}

\subsection{System Model}

\mnnote{NOTE: Ça me paraît correct mais confusant de parler d'un système centralisé pour un système P2P où seulement une fonctionnalité (le renommage) n'est disponible que pour un noeud particulier. Voir pour mieux présenter cet aspect}

\begin{itemize}
    \item Peer-to-peer network
    \begin{itemize}
        \item Nodes join and leave dynamically
    \end{itemize}
    \item Nodes build and maintain a sequence collaboratively using LogootSplit
    \begin{itemize}
        \item Each node owns a copy of the sequence and can edit it without any kind of coordination with others
    \end{itemize}
    \item The network is unreliable
    \begin{itemize}
        \item Messages can be lost, re-ordered and delivered multiple times
    \end{itemize}
    \item To overcome the faults of the network, a message-passing layer is used to deliver messages to the application exactly-once, in the correct order
    \begin{itemize}
        \item At each node, the insertion of a position happens before its removal
    \end{itemize}
    \item An anti-entropy mechanism is used by nodes to synchronise in a pairwise manner, by detecting and re-exchanging lost messages

    \item One node is arbitrarily designed as the leader
    \item This node only is able to trigger renamings
\end{itemize}

\subsection{Specification}

\begin{itemize}
    \item Introduce a new operation $rename$.
    \item This operation allows nodes to map each $position$ of their current sequence to a new one.
    \item Must be defined for all $positions$ of the current sequence of the node triggering the renaming...
    \item ... but also for all $positions$ which can be added concurrently by other nodes.
    \item The $rename$ operation must preserve the safety properties of the system, which are:
    \begin{itemize}
        \item The resulting sequences must be valid
        \item The nodes must converge
    \end{itemize}
    \item We define a sequence valid if
    \begin{itemize}
        \item Each position is unique. Thus a $rename$ operation should not associate several positions to the same resulting one. To put it in a more formal way, the $rename$ operation must be designed such as:

        \begin{center}
            $\nexists p1, p2 \in Pos \cdot rename(p1) = rename(p2)$
        \end{center}

        \item The sequence must be sorted with regards to the positions. The existing order between initial positions must then be preserved by the $rename$ operation. It results in the following property :

        \begin{center}
            $\forall p1, p2 \in Pos \land p1 < p2 \cdot rename(p1) < rename(p2)$
        \end{center}

    \end{itemize}

    \item To ensure the Strong Eventual Consistency of the system, the $rename$ must be:
    \begin{itemize}
        \item Determinist : an operation being applied without any kind of coordination by nodes, it must always produce the same output so that nodes reach the same state.
        \item Commutative with the $insert$ and $remove$ operations : as operations can be delivered in different orders at each node, for nodes to reach the same state in a coordination-free manner, the order of application of a set of operations must not have any impact on the resulting output.
        \begin{itemize}
            \item However, as only one node is able to trigger the renaming mechanism, it is impossible for concurrent $rename$ operations to exist. It is thus not required to design the $rename$ operation such as it is commutative with itself in this system model.
        \end{itemize}
    \end{itemize}
\end{itemize}

\subsection{Proposition}

\begin{itemize}
    \item Decompose the $rename$ operation into the following components and steps
\end{itemize}

\subsubsection{renamingMap}

\begin{itemize}
    \item The first step is to generate the $renamingMap$.
    \item This map is computed by the node which triggers the $rename$ operation
    \item It associates each existing position of its current sequence to a new one
    \item It will be used by every nodes to apply the renaming on their state
    \item \mnnote{TODO: Montrer qu'en se basant sur la renamingMap pour effectuer le renommage, on se découple de l'état courant du noeud au moment où il l'applique. Les noeuds prennent donc leurs décisions sur les mêmes entrées, ce qui garantit les mêmes résultats.}
    \item As it needs to be broadcast to other nodes, the size of the $renamingMap$ impacts the efficiency of the proposed solution
    \item A mechanism to compress the $renamingMap$ is introduced in section \ref{sec:optimisation-renamingMap}
    \item To compute this map, the node uses the algorithm \ref{alg:generateRenamingMap}

    \begin{algorithm}
        \caption{Generate renamingMap}
        \label{alg:generateRenamingMap}
        \begin{algorithmic}
        \Function{generateRenamingMap}{$S, id', seq'$}
            \State $renamingMap \gets Map()$
            \State
            \State $firstPos \gets S.getFirstPos()$
            \State $firstTuple \gets firstPos.getFirstTuple()$
            \State $priority \gets firstTuple.priority$
            \Comment Retrieve the priority of the first tuple of the first position
            \State
            \ForAll{$(pos, index) \in S$}
                \State $pos' \gets new \ Pos(\tuple{priority, id', seq', index})$
                \Comment Generate the new corresponding position
                \State $renamingMap.set(pos, pos')$
            \EndFor
            \State
            \State \Return $renamingMap$
        \EndFunction
        \end{algorithmic}
    \end{algorithm}

    \item This algorithm has the following behavior:
    \begin{itemize}
        \item Consist in generating a $Map$ associating each position of the sequence $S$ to a new position
        \item To optimise the resulting sequence, the new positions should be aggregable into one block
        \item i.e. the new positions must form a $position \ interval$
        \item First, have to pick a position as the beginning of the interval
        \item This choice is arbitrary
        \item In our case, pick the following position $pos'$:

        \begin{center}
            $pos' = \tuple{priority, id', seq', 0}$
        \end{center}

        where:

        \begin{itemize}
            \item $priority$ is the same value as the $priority$ of the first tuple of the first element of the sequence. We explain this choice in section \ref{sec:renameForwardPos}.
            \item $id'$ is the $id_{site}$ of the node performing the $rename$ operation
            \item $seq'$ is the current $seq_{site}$ of the node performing the $rename$ operation
        \end{itemize}

        \item The first position $pos$ of the current sequence will be map to $pos'$
        \item Then, all former positions are mapped to the consecutive ones of the new position according to the existing order
        \item All positions of the current sequence will be mapped to a set of positions which effectively form the following position interval $posInterval'$:

        \begin{center}
            $posInterval' = \tuple{pos', length - 1}$
        \end{center}

        where:

        \begin{itemize}
            \item $length$ is the length of the sequence
        \end{itemize}
    \end{itemize}

    \item \mnnote{TODO: Ajouter une phrase expliquant qu'on perd de l'information avec le renommage. Par exemple, on remplace le $id_{site}$ contenu dans la position qui identifie l'auteur de cet élément par $id'$ qui est l'identifiant de l'auteur du renommage}

\end{itemize}

\mnnote{NOTE: Le mappage des anciennes positions aux nouvelles se fait de manière séquentielle et ne dépend pas en finalité de la valeur de la position initiale.
    \\
    On peut tout à fait remplacer la $renamingMap$ par:
        \\
        - la liste des positions renommées
        \\
        - et une fonction qui calcule la nouvelle position à partir de l'index de la position renommée, de $priority$ de la 1ère position renommée, de $id$ du noeud qui a déclenché le renommage et sa valeur de $seq$ à ce moment là.
    \\
    Ceci permet de limiter les métadonnées conservées qu'à l'ancien état, et non plus l'ancien état + $n$ nouvelles positions de longueur 1 (1 nouvelle position pour chaque position renommée).
    \\
    Retravailler cette partie en conséquence ?
}

\subsubsection{\emph{Epoch-based} mechanism}

\begin{itemize}
    \item A renaming can be seen as a change of frame of reference, applied to positions
    \item Positions come from different frames according to if a renaming occurred between their generation
    \item We should not compare positions from different frames as it is meaningless
    \item It is thus necessary
    \begin{itemize}
        \item to define the frame of reference in which a given position is valid
        \item add information to the system to model this frame
    \end{itemize}
    \item To achieve this, we introduce the notion of \emph{epochs}
    \item The sequence has a default epoch : the \emph{origin} one
    \item When a renaming is performed, a new epoch is generated and replaces the current epoch of the sequence
    \item The set of these epochs forms a chain in the case of the centralised setting
    \item The renamingMaps presented previously allow nodes to move their sequence from one epoch to the next one
    \item By tagging operations with the current epoch at the time of generation, we can encapsulate its scope of validity
    \item Upon reception of an operation, a node is able to determine by comparing its current epoch to the epoch embedded in the operation if it can be applied or if additional steps are required beforehand
    \item To represent epochs, we use the following data structure:

    \begin{center}
        $\tuple{\tuple{epochNumber, id_{site}}, parentId}$
    \end{center}

    where:

    \begin{itemize}
        \item $epochNumber$ is the successor of the $epochNumber$ of the previous epoch
        \item $id_{site}$ is the identifier of the node which generated the epoch
        \item $\tuple{epochNumber, id_{site}}$ form the identifier of the epoch
        \item $parentId$ refers to the previous epoch by its identifier
    \end{itemize}
\end{itemize}

\subsubsection{Rename positions}
\label{sec:renameForwardPos}

\begin{itemize}
    \item To compute the new position corresponding to a given position in the new epoch, define the following function $renameForwardPos(renamingMap, pos) = pos'$
    \item Its behavior, which is detailed in algorithm \ref{alg:renameForwardPos}, can be described as follow:

    \begin{algorithm}
        \caption{Rename position}
        \label{alg:renameForwardPos}
        \begin{algorithmic}
        \Function{renameForwardPos}{$renamingMap, pos$}
            \If{$renamingMap.has(pos)$}
                \State \Return $renamingMap.get(pos)$
            \EndIf
            \State

            \State $renamedPositions \gets keysOf(renamingMap)$
            \State $firstPos \gets renamedPositions[0]$
            \State $lastPos \gets renamedPositions[renamedPositions.length - 1]$

            \State $newFirstPos \gets renamingMap.get(firstPos)$
            \State $newLastPos \gets renamingMap.get(lastPos)$

            \State $minFirstPos \gets min(firstPos, newFirstPos)$
            \State $maxLastPos \gets max(lastPos, newLastPos)$
            \State

            \If{$pos < minFirstPos$ \textbf{or} $maxLastPos < pos$}
                \State \Return $pos$
                \Comment Return the position unchanged as it does not conflict with the renaming
            \EndIf
            \State

            % \If{$lastPos < pos < newLastPos$}
            %     \State \Return $concat(newLastPos, pos)$
            % \EndIf
            % \State

            \If{$newFirstPos < pos < firstPos$}
                \State $<priority, id, seq, offset> \gets newFirstPos$
                \Comment Retrieve all components of $newFirstPos$
                \State $predecessorOfNewFirstPos \gets \tuple{priority, id, seq, offset - 1}$
                \State \Return $concat(predecessorOfNewFirstPos, pos)$
            \EndIf
            \State

            \State $predecessorOfPos \gets findPredecessor(renamedPositions, pos)$
            \State $newPredecessorOfPos \gets renamingMap.get(predecessorPos)$
            \State \Return $concat(newPredecessorOfPos, pos)$
        \EndFunction
        \end{algorithmic}
    \end{algorithm}

    \begin{itemize}
        \item If $pos$ was one of the positions belonging to the state when the $renamingMap$ was computed, then its renaming has already been decided and its new value is stored in the $renamingMap$. We just return it.
        \item If that is not the case, we need to compute the new position corresponding to it in the new frame of reference
        \item To be able to preserve the existing order between $pos$ and other positions through the renaming, we use different strategies according to the position's value:
        \begin{itemize}
            \item We define respectively as $firstPos$ and $lastPos$ the first and last positions contained in the entries of the $renamingMap$, and $newFirstPos$ and $newLastPos$ their images in the new frame of reference.
            \item If $pos$ is actually outside of the range impacted by the renaming, i.e \\ $pos < min(firstPos, newFirstPos)$ or $max(lastPos, newLastPos) < pos$, we can return it unchanged as it will not conflict with other renamed positions
            % \item If we have $lastPos < pos < newLastPos$, we rename $pos$ to shift it just after $newLastPos$ by concatenating $pos$ to $newLastPos$.
            \item If we have $newFirstPos < pos < firstPos$, we rename $pos$ to shift it just before $newFirstPos$ by concatenating $pos$ to the predecessor of $newFirstPos$. The predecessor of $newFirstPos$ is obtained by subtracting 1 to its $offset$ part.
            \item In the remaining case, it means that we have $firstPos < pos < maxLastPos$. In this case, we look for $predecessorOfPos$, the predecessor of $pos$ among the keys of $renamingMap$. Then, we retrieve the image of this position in the new state, $newPredecessorOfPos$. By concatenating $pos$ to $newPredecessorOfPos$, we are able to generate a new position while preserving the existing order.
        \end{itemize}
    \end{itemize}
    \item The main idea of this approach is to preserve the existing order between positions by concatenating the former positions to given prefixes to form the new positions.
    \item The greater the original position, the greater the prefix used to compose the new position.
    \item So, with $p1$ and $p2$ two positions such as $p1 < p2$ and $p1'$ and $p2'$ their respective renamed versions, we have
    \begin{itemize}
        \item either $p1'$ and $p2'$ sharing the same prefix. In that case, comparing $p1'$ and $p2'$ effectively comes down to comparing $p1$ and $p2$.
        \item either the prefix of $p2'$ is greater than the prefix of $p1'$.
    \end{itemize}
    \item In both cases, we have $p1' < p2'$.
    \item \mnnote{NOTE: Ce que je dis au-dessus concerne le cas où on a $firstPos < p1 < p2 < maxLastPos$, mais est vrai aussi pour le cas où on a $newFirstPos < p1 < firstPos < p2$ de façon moins évidente.
    \\
    Reste à montrer que l'ordre est conservé dans les cas limites ($p1 < newFirstPos < p2  < firstPos$; $p1 < maxLastPos < p2$).
    \\
    Renvoyer à la section validation.}
\end{itemize}

\subsubsection{Putting it all together}

\mnnote{
    TODO: Expliquer qu'on propose un nouveau CRDT, \emph{<insérer un nom ici>} (RenamableLogootSplit?).
    \\
    Cette structure de données encapsule une liste répliquée en utilisant LogootSplit, mais maintient aussi l'epoch courante, une map des epochs et les renamingMaps permettant d'avancer d'une epoch à l'autre.
    \\
    Dispose des fonctions présentées précédemment, generateRenamingMap() et renameForwardPos().
    \\
    Propose la fonction $rename()$ qui retourne la séquence renommée en appliquant $renameForwardPos$ à chaque position de l'état courant.
    \\
    Surcharge le traitement des opérations $insert$ et $delete$ pour:
    \\
        - Déléguer le traitement de l'opération à l'instance de LogootSplit si l'epoch de génération correspond à l'epoch courante
        \\
        - Ou transformer l'opération au préalable à l'aide de renameForwardPos() (potentiellement à travers plusieurs epochs) si les epochs ne correspondent pas.
        \\
    Indiquer qu'on a une contrainte supplémentaire pour la livraison des opérations : elles doivent être livrées dans l'ordre causal par rapport à la dernière opération de renommage observée (doit être à la même epoch que celle de génération de l'opération ou à une epoch suivante pour pouvoir appliquer une opération).
}

\subsection{Garbage collection}

\begin{itemize}
    \item As stated previously, the renaming mechanism generates and stores additional metadata: the epochs and the renamingMaps used to transform concurrent operations against the renaming
    \item However, we do not need to keep this additional metadata forever
    \item Since they are used to handle concurrent operations to the renaming, they are not required anymore once no additional concurrent operation can be issued by a node
    \item i.e. we can safely garbage collect rewriting rules once the corresponding renaming operation is causally stable \cite{10.1007/978-3-662-43352-2_11}
    \item Nodes need thus to keep track of the progress of others to detect when this condition is met
    \item This can be done in a coordination-free manner by exploiting the epochs attached to operations:
    \begin{itemize}
        \item Each node stores a vector of epochs, with one entry for each node
        \item Upon the reception of an operation, the node updates the entry of the sender with the epoch of the operation
        \item As nodes collaborates, epochs in the vector will progress
        \item By retrieving the minimum epoch from the vector, we can identify which epoch has been reached by all nodes
        \item We can then safely garbage collect all previous epochs and corresponding renamingMaps
    \end{itemize}
\end{itemize}

\subsection{Limits}

\subsubsection{Size of concurrently generated positions}

\mnnote{TODO: Ajouter quelques lignes sur le fait que le renommage a pour effet d'augmenter la taille des positions insérées en concurrence. Tempérer ce problème en argumentant que ce nombre de positions concurrentes devrait s'avérer faible par rapport au nombre total de positions contenues dans la séquence et qu'elles seront de toute façon réduites au cours du renommage suivant.}

\subsubsection{Fault-tolerance}

\begin{itemize}
    \item The system is vulnerable to failures, as only one particular node is able to trigger renamings
    \begin{itemize}
        \item A failure of this node would prevent the renaming mechanism from being triggered ever again
        \item But other nodes would still be able to continue their collaboration in such scenario
        \item The failure of the renaming mechanism does not impede the liveness of the system
    \end{itemize}
    \item To address this fault-tolerance issue, can set up a consensus-based system
    \begin{itemize}
        \item Require nodes to perform a consensus to trigger a renaming
        \item But consensus algorithms are expensive and not suited for dynamic systems
        \item Can adapt the idea introduced in \cite{letia:hal-01248270}
        \item In this paper, authors propose to divide a distributed system into two tiers:
        the \emph{Core}, a small set of controlled and stable nodes, and the \emph{Nebula}, an uncontrolled set of nodes
        \begin{itemize}
            \item Only nodes from the \emph{Core} would participate in the consensus leading to a renaming
        \end{itemize}
        \item Provide a trade-off between the cost of performing a renaming and the resilience of the system
    \end{itemize}
    \item But this approach is not suited for all kind of applications
    \item In fully distributed systems, there is no central authority to provide a set of stable nodes acting as the \emph{Core}
\end{itemize}

\section{Renaming in a fully distributed setting}

\subsection{System Model}
\subsection{Intuition}
\subsection{Strategy to determine leading epoch in case of concurrency}
\subsection{Transitioning from a losing epoch to the leading one}
\subsection{Garbage collection}

\section{Evaluation}

\section{Discussion}

\subsection{Offloading on disk unused renaming rules}

\begin{itemize}
    \item As stated previously, nodes have to keep renamingMaps as long as another nodes may issue operations which would require to be transformed to be applied
    \item Thus nodes need to keep track of the progress of others to determine if such operations can still be issued or if it is safe to garbage collect the renaming rules
    \item In a fully distributed setting, this requirement is difficult to reach as nodes may join the collaboration, perform some operations and then disconnect
    \item Other nodes, from their point of view, are not able to determine if they disconnected temporarily or if it left definitely the collaboration
    \item However, as the disconnected nodes stopped progressing, they hold back the whole system and keep the current active nodes from garbage collecting old renaming rules
    \item To limit the impact of stale nodes on active ones, we propose that nodes offload unused renamingMaps by storing them on disk
\end{itemize}

\mnnote{TODO: Présenter une méthode pour déterminer les règles de renommage non-utilisées (conserver uniquement les règles utilisées pour traiter les $x$ dernières opérations ?)}

\subsection{Alternative strategy to determine leading epoch}
\subsection{Postponing transition between epochs in case of instability}

\begin{itemize}
    \item May reach a situation in which several nodes keep generating concurrent renaming operations on different epoch branches
    \item In such case, switching repeatedly between these concurrent branches may prove wasteful
    \item However, as long as nodes possess the required renamingMaps, they are able to rewrite operations from the other side and to integrate them into their copy, even if they are not on the latest epoch of their branch
    \begin{itemize}
        \item At the cost of an overhead per operation
    \end{itemize}
    \item Thus not moving to the new current epoch does not impede the liveness of the system
    \item Nodes can wait until one branch arise as the leading one then move to this epoch
    \item To speed up the emergence of such a branch, communications can be increased between nodes in such case to ease synchronisation
\end{itemize}

\subsection{Compressing the renaming operation}

\label{sec:optimisation-renamingMap}

\mnnote{TODO: Retravailler pour y ajouter la notion d'offset. Par contre, faire remarquer qu'on a pas besoin de l'offset pour identifier de manière unique "la base" d'une position (toute la position sauf l'offset)}

\begin{itemize}
    \item Propagating the renaming operation consists in broadcasting the list of blocks on which the renaming was performed, so that other nodes are able to compute the same rewriting rules
    \item This could prove costly, as the state before renaming can be composed of many blocks, each using long positions
    \item We propose an approach to compress this operation to reduce its bandwidth consumption at the cost of additional computations to process it
    \item Despite the variable length of positions, the parts required to identify an position uniquely are fixed
    \begin{itemize}
        \item We only need the $siteId$ and the $seq$ of the last tuple of the position to do so
    \end{itemize}
    \item Instead of broadcasting the list of whole positions, the node which performs the renaming can just broadcast the list of tuples $<siteId, seq>$
    \item On reception of a compressed renaming operation, a node needs first to regenerate the list of renamed blocks to be able to apply it
    \item To achieve so, it can browse its current state looking for positions with corresponding tuples $<siteId, seq>$
    \item If some positions are missing from the state, it means that they were deleted concurrently
    \item The node can thus browse the concurrent remove operations to the renaming one to find the missing blocks
    \item Once all positions has been retrieved and the list of blocks computed, the renaming operation can be processed normally
\end{itemize}

\subsection{Operational Transformation}

\mnnote{NOTE: Ajouter une section sur OT pour expliquer que gérer les opérations concurrentes aux renommages consiste en finalité à transformer ces opérations, mais qu'on a décidé de ne pas présenter et formaliser l'approche comme étant de l'OT dans ce papier pour des raisons de simplicité ?}

\section{Conclusion}

\printbibliography

\end{document}
