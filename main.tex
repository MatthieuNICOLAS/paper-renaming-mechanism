\documentclass{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

\usepackage{acronym} % \ac[p], \acl[p], \acs[p], \acf[p]
\usepackage{algorithm} % \begin{algorithm} \end{algorithm}
\usepackage{algpseudocode} % \begin{algorithmic} \end{algorithmic}
\usepackage{authblk} % \affil
\usepackage[defernumbers=true, sorting=none]{biblatex}
\usepackage[inline]{enumitem} % \begin{enumerate*} \end{enumerate*}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{color}
\AtBeginDocument{
\definecolor{pdfurlcolor}{rgb}{0,0,0}
\definecolor{pdfcitecolor}{rgb}{0,0,0}
\definecolor{pdflinkcolor}{rgb}{0,0,0}
\definecolor{light}{gray}{.85}
\definecolor{vlight}{gray}{.95}
\definecolor{darkgreen}{rgb}{0.0, 0.2, 0.13}
}
\usepackage{hyperref}

\newcommand{\email}[1]{\href{mailto:#1}{#1}}

\usepackage[draft,inline,nomargin,index]{fixme}
\fxsetup{theme=colorsig,mode=multiuser,inlineface=\itshape,envface=\itshape}
\FXRegisterAuthor{go}{ago}{Gerald}
\FXRegisterAuthor{mn}{amn}{Matthieu}

% Acronyms
% --------
\acrodef{ADT}[ADT]{Abstract Data Type}
\acrodefplural{ADT}[ADTs]{Abstract Data Types}

\acrodef{CRDT}[CRDT]{Conflict-free Replicated Data Type}
\acrodefplural{CRDT}[CRDTs]{Conflict-free Replicated Data Types}

\acrodef{SEC}[SEC]{Strong Eventual Consistency}

% Meta-Data
% ---------

\hypersetup{pdftitle={In progress},
    pdfsubject={},
    pdfkeywords={Data replication, CRDT},
    pdfauthor={M. Nicolas, O. Perrin, G. Oster}}

%\pagestyle{empty}

\addbibresource{ref.bib}

\begin{document}

\title{Improving Replicated Sequences Performances}
\author{Matthieu Nicolas}
\author{Gérald Oster}
\author{Olivier Perrin}
\affil{Université de Lorraine, CNRS, Inria, LORIA, F-54500, France}
\date{}

\maketitle

\section{Introduction}

\section{Replicated Sequences}

\subsection{Sequence}

\begin{itemize}
    \item \ac{ADT} which allows to represent a list of values
    \item Provide two operations to update the sequence, $insert$ and $remove$
    \item $insert(S, index, elt) = S'$ inserts the value $elt$ at the index $index$ into the sequence $S$ and returns the updated sequence $S'$
    \item $remove(S, index) = S'$ removes from the sequence $S$ the value at the index $index$ and returns the updated sequence $S'$
\end{itemize}

\subsection{\acp{CRDT} \cite{shapiro:inria-00555588, shapiro_2011_crdt}}

\begin{itemize}
    \item Optimistically replicated data structure
    \item Updates performed without coordination between nodes
    \item Ensure \ac{SEC} \cite{shapiro_2011_crdt}
\end{itemize}

\subsection{Logoot \cite{WeissICDCS09}}

\begin{itemize}
    \item Element-wise Sequence \ac{CRDT}
    \item Key insight is to replace changing and unreliable $indexes$ with universal and immutable $positions$
    \begin{itemize}
        \item $indexes$ are adapted for sequential executions
        \item They are closely tied to the current state of the sequence, as updating the later shift them
        \item However, they can not be used in a distributed setting, in which the order of the execution of the updates can be different from one node to another, to embody the user's intention
        \item Conversely, Logoot's $positions$ are designed to be independent of the state
        \item This allows the definition of commutative operations, providing a $Sequence$ suited for distributed settings
    \end{itemize}

    \mnnote{TODO: Insérer un exemple de manipulation concurrente d'une séquence (ins/remove en parallèle), sans mécanisme de résolution de conflits, pour illustrer la divergence du résultat si on ne se base que sur des index}

    \item When inserting an element into the sequence, a fitting $position$ is computed by the node and associated to the element
    \item These $positions$ perform several roles
    \begin{itemize}
        \item They identify uniquely an element
        \item They order the elements relatively to each other
    \end{itemize}
    \item To be able to perform these roles, $positions$ need to comply with several constraints
    \begin{itemize}
        \item Be globally unique: several nodes should not able to compute the same $position$ concurrently
        \item Be temporarily unique: a node should not be able to associate the same $position$ to different elements during the lifetime of the sequence
        \item Be totally ordered: a order relation must exist over $positions$ so a node can order two elements given their respective $position$
        \item Belong to a dense set: a node should always be able to generate a new $position$ between two others
    \end{itemize}
    \item To comply with these constraints, Logoot $positions$ are composed of one or several of the following tuples:

    \begin{center}
        $<priority, id_{site}, seq_{site}>$
    \end{center}

    where:

    \mnnote{NOTE: on utilise actuellement des entiers pour représenter les éléments des tuples à l'heure actuelle mais pourrait utiliser n'importe quel type disposant d'une relation d'ordre, donc je ne sais pas quel type indiquer ici}
    \begin{itemize}
        \item $priority$ allows to determine the location of this position relatively to others
        \item $id_{site}$ refers to the node's identifier, assumed to be unique
        \item $seq_{site}$ refers to the node's logical clock, which increases monotonically with local updates
    \end{itemize}

    \mnnote{TODO: Reprendre l'exemple précédent, mais en remplaçant les index par des positions Logoot, pour illustrer la convergence}

    \item It is worth to notice that: \mnnote{J'illustre dans les prochains points comment la composition d'une position permet d'assurer l'ensemble des contraintes stipulées précédemment, mais l'explication concernant l'espace dense se révèle être particulièrement complexe et nécessiter de rentrer dans des détails. À garder ?}
    \begin{itemize}
        \item The couple $<id_{site}, seq_{site}>$ of the last tuple of the position ensures its uniqueness as
        \begin{itemize}
            \item No other node can generate a position using the same $id_{site}$ as it is unique
            \item No other position can be generated by the same node using the same $seq_{site}$ as it is increasing monotonically with local updates
        \end{itemize}
        \item Every part of positions can be used to define a total order based on the lexicographical order
        \item To ensure that positions form a dense set, we have to reserve exclusively the usage of the minimal value of $priority$ to a specific tuple, $minTuple$. By doing this we have, for every other tuple $t$, $minTuple < t$. $minTuple$ is then used only as an intermediary tuple, the default value when a node has to generate a tuple less than another one, but is not able to. Thus, given two positions $p1$ and $p2$ such as $p1 < p2$, any node is always able to generate a new position $p3$ such as $p1 < p3 < p2$ by reusing the tuples of $p1$, appending $minTuple$ as many times as required and finally adding its own new tuple $t$.
    \end{itemize}
    \item Updates the definition of the operations $insert$ and $remove$ to take into account these changes
    \begin{itemize}
        \item $insert(S, pos, elt) = S'$ inserts the value $elt$ at the position $pos$ into the sequence $S$ and returns the updated sequence $S'$
        \item $remove(S, pos) = S'$ removes from the sequence $S$ the value at the position $pos$ and returns the updated sequence $S'$
    \end{itemize}
    \item Provides some functions to nodes so they can obtain $positions$ from $indexes$
    \begin{itemize}
        \item $generatePos(S, index) = pos$ generates a new position $pos$ corresponding to the index $index$ of the current sequence $S$
        \item $getPos(S, index) = pos$ retrieves the position $pos$ of the element at the index $index$ in the current sequence $S$
    \end{itemize}
\end{itemize}

\subsection{LogootSplit \cite{AndreCollaborateCom2013}}

\begin{itemize}
    \item Block-wise Sequence \acp{CRDT}
    \item Goal is to improve further the performances of Logoot
    \item It is expensive to generate and associate a position to each element of the sequence
    \item \textcite{AndreCollaborateCom2013} proposes to aggregate dynamically elements into blocks
    \item It allows to reduce the metadata per element as we only need to store a $position \ interval$ for a block, independently of how many elements it contains
    \item To do so, add a new component to positions tuples: the $offset$ \mnnote{Préciser que $offset$ doit appartenir à un ensemble énumérable, de façon à ce que l'on puisse déterminer son prédecesseur, successeur ou si une valeur est manquante ?}
    \item LogootSplit $positions$ are thus composed of one or several of the following tuples:

    \begin{center}
        $<priority, id_{site}, seq_{site}, offset>$
    \end{center}

    \item Define positions as aggregable if all components but the $offsets$ of their last tuple are identical and if their respective $offsets$ are consecutive
    \item Define $position \ interval$ as the following couple:

    \begin{center}
        $<posBegin, end>$
    \end{center}

    where:

    \begin{itemize}
        \item $posBegin$ refers to the first position of the interval
        \item $end$ refers to the value of the offset of the last position of the interval
    \end{itemize}

    \item Given these two values, we are able to recreate all positions from the interval if needed
    \item It is worth to notice that
    \begin{itemize}
        \item The uniqueness of a LogootSplit position is ensured by the triple $<id_{site}, seq_{site}, offset>$
        \item As such, an $offset$ can not be used twice for the same block
        \item It is then necessary to prevent such a case from happening when a node prepend or append a new element to an existing block
        \item It can be achieved by keeping track of used $offset$ per block
        \begin{itemize}
            \item To be more precise, only need to keep track of the minimum and maximum $offsets$ ever used for this block
        \end{itemize}
    \end{itemize}

    \item Updates the definition of the operations $insert$ and $remove$ to make them block-wise
    \begin{itemize}
        \item $insert(S, pos, elts) = S'$ inserts into the sequence $S$ the values $elts$ from the position $pos$. Returns the updated sequence $S'$
        \item $remove(S, posIntervals) = S'$ removes from the sequence $S$ the values with their position contained in one of the interval of $posIntervals$ and returns the updated sequence $S'$
    \end{itemize}
    \item Also introduce the following function:
    \begin{itemize}
        \item $getPosIntervals(S, index, length) = posIntervals$ retrieves the list of $position \ intervals$  at the index $index$ in the current sequence $S$
    \end{itemize}
\end{itemize}

\subsection{Limits}

\begin{itemize}
    \item As shown previously, LogootSplit positions' size is not bounded in order to comply with the dense set constraint
    \item Positions will become longer as the collaboration progresses, downgrading the performances of the application \mnnote{NOTE: trouver un autre terme que "collaboration"?}
    \begin{itemize}
        \item Since nodes have to broadcast positions, store them but also compare them to determine their order
    \end{itemize}
    \item \mnnote{Ici j'aimerais aussi ajouter quelques mots pour expliquer que le nombre de blocs influe négativement sur les performances de l'application (augmente le temps de parcours de la liste, et donc le temps d'exécution d'une insertion ou d'une suppression; doit conserver un $position \ interval$ pour chaque bloc). Une séquence est donc optimale si elle composée d'un unique bloc. Mais en raison des contraintes définissant les positions aggrégeables (insertions à des index consécutifs par un même noeud, sans suppression intermédiaire) et de l'absence de mécanisme pour fusionner à posteriori les blocs existants, les séquences issues d'une collaboration sont généralement morcelées en de nombreux blocs.}
\end{itemize}

\section{Overview}

\begin{itemize}
    \item We build up on top of LogootSplit
    \item To address its limitations, we introduce a renaming mechanism
    \item The purpose of this mechanism is to reassign shorter positions to each element such as all of them can be aggregated into one unique block
    \item This allows to reduce the metadata per element, the computation time required to apply next updates and also the bandwidth used to broadcast future updates
    \item \mnnote{TODO: Expliquer que toutefois le mécanisme de renommage ajoute un coût et qu'on cherche à le minimiser. Mais j'ai du mal à voir comment introduire la notion de cet overhead sans rentrer dans les détails qui en sont la source (règles de réécriture, arborescence des epochs, transformation des opérations concurrentes), que je préférerais introduire un par un dans la suite du papier}
    \item For simplicity purposes, will first present the renaming mechanism in the context of a centralised system, with only one node able to trigger the renaming mechanism
    \begin{itemize}
        \item Will describe the functioning of this initial version and discuss its limitations
    \end{itemize}
    \item Will then present a more elaborated version of the renaming mechanism, overcoming the limitations of the centralised version and allowing its use in a distributed setting
\end{itemize}

\section{Renaming in a centralised setting}

\subsection{System Model}

\mnnote{NOTE: Ça me paraît correct mais confusant de parler d'un système centralisé pour un système P2P où seulement une fonctionnalité (le renommage) n'est disponible que pour un noeud particulier. Voir pour mieux présenter cet aspect}

\begin{itemize}
    \item Peer-to-peer network
    \begin{itemize}
        \item Nodes join and leave dynamically
    \end{itemize}
    \item Nodes build and maintain a sequence collaboratively using LogootSplit
    \begin{itemize}
        \item Each node owns a copy of the sequence and can edit it without any kind of coordination with others
    \end{itemize}
    \item The network is unreliable
    \begin{itemize}
        \item Messages can be lost, re-ordered and delivered multiple times
    \end{itemize}
    \item To overcome the faults of the network, a message-passing layer is used to deliver messages to the application exactly-once, in the correct order
    \begin{itemize}
        \item At each node, the insertion of a position happens before its removal
    \end{itemize}
    \item An anti-entropy mechanism is used by nodes to synchronise in a pairwise manner, by detecting and re-exchanging lost messages

    \item One node is arbitrarily designed as the leader
    \item This node only is able to trigger renamings
\end{itemize}

\subsection{Specification}

\begin{itemize}
    \item Introduce a new operation $rename$
    \item This operation allows nodes to map each $position$ of their current sequence to a new one
    \item Must be defined for all $positions$ of the current sequence of the node triggering the renaming...
    \item ... but also for all $positions$ which can be added concurrently by other nodes
    \item To ensure the correctness of the resulting sequences, this operation must comply with several properties
    \begin{itemize}
        \item $position \ uniqueness \ preservation$ : as $positions$ must be unique, a $rename$ operation should not map several $positions$ to the same resulting one
        \item $order \ preservation$ : as $positions$ ensures the order of their respective element, a $rename$ operation should not shuffle this order
    \end{itemize}
    \item To ensure the eventual consistency of the system, the $rename$ operation must also be commutative with the other operations $insert$ and $delete$ as nodes may receive and apply them in different orders
    \begin{itemize}
        \item As no concurrent $rename$ operation can be issued, since only node is able to trigger the renaming mechanism, there is no need to design the $rename$ operation as commutative with itself
    \end{itemize}
\end{itemize}

\subsection{Proposition}

\begin{itemize}
    \item Decompose the $rename$ operation into the following components and steps
\end{itemize}

\subsubsection{renamingMap}

\begin{itemize}
    \item The first step is to generate the $renamingMap$.
    \item This map is computed by the node which triggers the $rename$ operation
    \item It associates each existing position of its current sequence to a new one
    \item It will be used by every nodes to apply the renaming on their state
    \item As it needs to be broadcasted to other nodes, the size of the $renamingMap$ impacts the efficiency of the proposed solution
    \item A mechanism to compress the $renamingMap$ is introduced in section \ref{sec:optimisation-renamingMap}
    \item To compute this map, the node uses the algorithm \ref{alg:generateRenamingMap}

    \begin{algorithm}
        \caption{Generate renamingMap}
        \label{alg:generateRenamingMap}
        \begin{algorithmic}
        \Function{generateRenamingMap}{$S, id', seq'$}
            \State $renamingMap \gets Map()$
            \State
            \State $firstPos \gets S.getFirstPos()$
            \State $firstTuple \gets firstPos.getFirstTuple()$
            \State $priority \gets firstTuple.priority$
            \Comment Retrieve the priority of the first tuple of the first position
            \State
            \ForAll{$(pos, index) \in S$}
                \State $pos' \gets new \ Pos(<priority, id', seq', index>)$
                \Comment Generate the new corresponding position
                \State $renamingMap.set(pos, pos')$
            \EndFor
            \State
            \State \Return $renamingMap$
        \EndFunction
        \end{algorithmic}
    \end{algorithm}

    \item This algorithm has the following behavior:
    \begin{itemize}
        \item Consist in generating a $Map$ associating each position of the sequence $S$ to a new position
        \item To optimise the resulting sequence, the new positions should be aggregable into one block
        \item i.e. the new positions must form a $position \ interval$
        \item First, have to pick a position as the beginning of the interval
        \item This choice is arbitrary
        \item In our case, pick the following position $pos'$:

        \begin{center}
            $pos' = <priority, id', seq', 0>$
        \end{center}

        where:

        \begin{itemize}
            \item $priority$ is the same value as the $priority$ of the first tuple of the first element of the sequence. We explain this choice in section \ref{sec:renameForwardPos}.
            \item $id'$ is the $id_{site}$ of the node performing the $rename$ operation
            \item $seq'$ is the current $seq_{site}$ of the node performing the $rename$ operation
        \end{itemize}

        \item The first position $pos$ of the current sequence will be map to $pos'$
        \item Then, all former positions are mapped to the consecutive ones of the new position according to the existing order
        \item All positions of the current sequence will be mapped to a set of positions which effectively form the following position interval $posInterval'$:

        \begin{center}
            $posInterval' = <pos', length - 1>$
        \end{center}

        where:

        \begin{itemize}
            \item $length$ is the length of the sequence
        \end{itemize}
    \end{itemize}

    \item \mnnote{TODO: Ajouter une phrase expliquant qu'on perd de l'information avec le renommage. Par exemple, on remplace le $id_{site}$ contenu dans la position qui identifie l'auteur de cet élément par $id'$ qui est l'identifiant de l'auteur du renommage}

\end{itemize}

\mnnote{NOTE: Le mappage des anciennes positions aux nouvelles se fait de manière séquentielle et ne dépend pas en finalité de la valeur de la position initiale.
    \\
    On peut tout à fait remplacer la $renamingMap$ par:
        \\
        - la liste des positions renommées
        \\
        - et une fonction qui calcule la nouvelle position à partir de l'index de la position renommée, de $priority$ de la 1ère position renommée, de $id$ du noeud qui a déclenché le renommage et sa valeur de $seq$ à ce moment là.
    \\
    Ceci permet de limiter les métadonnées conservées qu'à l'ancien état, et non plus l'ancien état + $n$ nouvelles positions de longueur 1 (1 nouvelle position pour chaque position renommée).
    \\
    Retravailler cette partie en conséquence ?
}

\subsubsection{\emph{Epoch-based} mechanism}

\begin{itemize}
    \item A renaming can be seen as a change of frame of reference, applied to positions
    \item Positions come from different frames according to if a renaming occurred between their generation
    \item We should not compare positions from different frames as it is meaningless
    \item It is thus necessary
    \begin{itemize}
        \item to define the frame of reference in which a given position is valid
        \item add information to the system to model this frame
    \end{itemize}
    \item To achieve this, we introduce the notion of \emph{epochs}
    \item The sequence has a default epoch : the \emph{origin} one
    \item When a renaming is performed, a new epoch is generated and replaces the current epoch of the sequence
    \item The set of these epochs forms a chain in the case of the centralised setting
    \item The renamingMaps presented previously allow nodes to move their sequence from one epoch to the next one
    \item By tagging operations with the current epoch at the time of generation, we can encapsulate its scope of validity
    \item Upon reception of an operation, a node is able to determine by comparing its current epoch to the epoch embedded in the operation if it can be applied or if additional steps are required beforehand
    \item To represent epochs, we use the following data structure:

    \begin{center}
        $epoch = <<epochNumber, id_{site}>, parentId>$
    \end{center}

    where:

    \begin{itemize}
        \item $epochNumber$ is the successor of the $epochNumber$ of the previous epoch
        \item $id_{site}$ is the identifier of the node which generated the epoch
        \item $<epochNumber, id_{site}>$ form the identifier of the epoch
        \item $parentId$ refers to the previous epoch by its identifier
    \end{itemize}
\end{itemize}

\subsubsection{Rename positions}
\label{sec:renameForwardPos}

\begin{itemize}
    \item To compute the new position corresponding to a given position in the new epoch, define the following function $renameForwardPos(renamingMap, pos) = pos'$
    \item Its behavior, which is detailed in algorithm \ref{alg:renameForwardPos}, can be described as follow:

    \begin{algorithm}
        \caption{Rename position}
        \label{alg:renameForwardPos}
        \begin{algorithmic}
        \Function{renameForwardPos}{$renamingMap, pos$}
            \If{$renamingMap.has(pos)$}
                \State \Return $renamingMap.get(pos)$
            \EndIf
            \State

            \State $renamedPositions \gets keysOf(renamingMap)$
            \State $firstPos \gets renamedPositions[0]$
            \State $lastPos \gets renamedPositions[renamedPositions.length - 1]$

            \State $newFirstPos \gets renamingMap.get(firstPos)$
            \State $newLastPos \gets renamingMap.get(lastPos)$

            \State $minFirstPos \gets min(firstPos, newFirstPos)$
            \State $maxLastPos \gets max(lastPos, newLastPos)$
            \State

            \If{$pos < minFirstPos$ \textbf{or} $maxLastPos < pos$}
                \State \Return $pos$
                \Comment Return the position unchanged as it does not conflict with the renaming
            \EndIf
            \State

            % \If{$lastPos < pos < newLastPos$}
            %     \State \Return $concat(newLastPos, pos)$
            % \EndIf
            % \State

            \If{$newFirstPos < pos < firstPos$}
                \State $<priority, id, seq, offset> \gets newFirstPos$
                \Comment Retrieve all components of $newFirstPos$
                \State $predecessorOfNewFirstPos \gets <priority, id, seq, offset - 1>$
                \State \Return $concat(predecessorOfNewFirstPos, pos)$
            \EndIf
            \State

            \State $predecessorOfPos \gets findPredecessor(renamedPositions, pos)$
            \State $newPredecessorOfPos \gets renamingMap.get(predecessorPos)$
            \State \Return $concat(newPredecessorOfPos, pos)$
        \EndFunction
        \end{algorithmic}
    \end{algorithm}

    \begin{itemize}
        \item If $pos$ was one of the positions belonging to the state when the $renamingMap$ was computed, then its renaming has already been decided and its new value is stored in the $renamingMap$. We just return it.
        \item If that is not the case, we need to compute the new position corresponding to it in the new frame of reference
        \item To be able to preserve the existing order between $pos$ and other positions through the renaming, we use different strategies according to the position's value:
        \begin{itemize}
            \item We define respectively as $firstPos$ and $lastPos$ the first and last positions contained in the entries of the $renamingMap$, and $newFirstPos$ and $newLastPos$ their images in the new frame of reference.
            \item If $pos$ is actually outside of the range impacted by the renaming, i.e \\ $pos < min(firstPos, newFirstPos)$ or $max(lastPos, newLastPos) < pos$, we can return it unchanged as it will not conflict with other renamed positions
            % \item If we have $lastPos < pos < newLastPos$, we rename $pos$ to shift it just after $newLastPos$ by concatenating $pos$ to $newLastPos$.
            \item If we have $newFirstPos < pos < firstPos$, we rename $pos$ to shift it just before $newFirstPos$ by concatenating $pos$ to the predecessor of $newFirstPos$. The predecessor of $newFirstPos$ is obtained by subtracting 1 to its $offset$ part.
            \item In the remaining case, it means that we have $firstPos < pos < newLastPos$. In this case, we look for $predecessorOfPos$, the predecessor of $pos$ among the keys of $renamingMap$. Then, we retrieve the image of this position in the new state, $newPredecessorOfPos$. By concatenating $pos$ to $newPredecessorOfPos$, we are able to generate a new position while preserving the existing order.
        \end{itemize}
    \end{itemize}
    \item The main idea of this approach is that we preserve the existing order between positions by concatenating the former positions to given prefixes to form the new positions.
    \item The greater the original position, the greater the prefix used to compose the new position.
    \item So, with $p1$ and $p2$ two positions such as $p1 < p2$ and $p1'$ and $p2'$ their respective renamed versions, we have
    \begin{itemize}
        \item either $p1'$ and $p2'$ sharing the same prefix. In that case, comparing $p1'$ and $p2'$ effectively comes down to comparing $p1$ and $p2$.
        \item either the prefix of $p2'$ is greater than the prefix of $p1'$.
    \end{itemize}
    \item In both cases, we have $p1' < p2'$.
    \item \mnnote{NOTE: Ce que je dis au-dessus concerne le cas où on a $firstPos < p1 < p2 < newLastPos$, mais est vrai aussi pour le cas où on a $newFirstPos < p1 < firstPos < p2$ de façon moins évidente.
    \\
    Reste à montrer que l'ordre est conservé dans les cas limites ($p1 < newFirstPos < p2  < firstPos$; $lastPos < p1 < newLastPos < p2$).
    \\
    Renvoyer à la section validation.}
\end{itemize}

\subsubsection{Putting it all together}

\mnnote{
    TODO: Expliquer qu'on propose un nouveau CRDT, \emph{<insérer un nom ici>} (RenamableLogootSplit?).
    \\
    Cette structure de données encapsule une liste répliquée en utilisant LogootSplit, mais maintient aussi l'epoch courante, une map des epochs et les renamingMaps permettant d'avancer d'une epoch à l'autre.
    \\
    Dispose des fonctions présentées précédemment, generateRenamingMap() et renameForwardPos().
    \\
    Propose la fonction $rename()$ qui retourne la séquence renommée en appliquant $renameForwardPos$ à chaque position de l'état courant.
    \\
    Surcharge le traitement des opérations $insert$ et $delete$ pour:
    \\
        - Déléguer le traitement de l'opération à l'instance de LogootSplit si l'epoch de génération correspond à l'epoch courante
        \\
        - Ou transformer l'opération au préalable à l'aide de renameForwardPos() (potentiellement à travers plusieurs epochs) si les epochs ne correspondent pas.
        \\
    Indiquer qu'on a une contrainte supplémentaire pour la livraison des opérations : elles doivent être livrées dans l'ordre causal par rapport à la dernière opération de renommage observée (doit être à la même epoch que celle de génération de l'opération ou à une epoch suivante pour pouvoir appliquer une opération).
}

\subsection{Garbage collection}

\begin{itemize}
    \item As stated previously, the renaming mechanism generates and stores additional metadata: the epochs and the renamingMaps used to transform concurrent operations against the renaming
    \item However, we do not need to keep this additional metadata forever
    \item Since they are used to handle concurrent operations to the renaming, they are not required anymore once no additional concurrent operation can be issued by a node
    \item i.e. we can safely garbage collect rewriting rules once the corresponding renaming operation is causally stable \cite{10.1007/978-3-662-43352-2_11}
    \item Nodes need thus to keep track of the progress of others to detect when this condition is met
    \item This can be done in a coordination-free manner by exploiting the epochs attached to operations:
    \begin{itemize}
        \item Each node stores a vector of epochs, with one entry for each node
        \item Upon the reception of an operation, the node updates the entry of the sender with the epoch of the operation
        \item As nodes collaborates, epochs in the vector will progress
        \item By retrieving the minimum epoch from the vector, we can identify which epoch has been reached by all nodes
        \item We can then safely garbage collect all previous epochs and corresponding renamingMaps
    \end{itemize}
\end{itemize}

\subsection{Limits}

\subsubsection{Size of concurrently generated positions}

\mnnote{TODO: Ajouter quelques lignes sur le fait que le renommage a pour effet d'augmenter la taille des positions insérées en concurrence. Tempérer ce problème en argumentant que ce nombre de positions concurrentes devrait s'avérer faible par rapport au nombre total de positions contenues dans la séquence et qu'elles seront de toute façon réduites au cours du renommage suivant.}

\subsubsection{Fault-tolerance}

\begin{itemize}
    \item The system is vulnerable to failures, as only one particular node is able to trigger renamings
    \begin{itemize}
        \item A failure of this node would prevent the renaming mechanism from being triggered ever again
        \item But other nodes would still be able to continue their collaboration in such scenario
        \item The failure of the renaming mechanism does not impede the liveness of the system
    \end{itemize}
    \item To address this fault-tolerance issue, can set up a consensus-based system
    \begin{itemize}
        \item Require nodes to perform a consensus to trigger a renaming
        \item But consensus algorithms are expensive and not suited for dynamic systems
        \item Can adapt the idea introduced in \cite{letia:hal-01248270}
        \item In this paper, authors propose to divide a distributed system into two tiers:
        the \emph{Core}, a small set of controlled and stable nodes, and the \emph{Nebula}, an uncontrolled set of nodes
        \begin{itemize}
            \item Only nodes from the \emph{Core} would participate in the consensus leading to a renaming
        \end{itemize}
        \item Provide a trade-off between the cost of performing a renaming and the resilience of the system
    \end{itemize}
    \item But this approach is not suited for all kind of applications
    \item In fully distributed systems, there is no central authority to provide a set of stable nodes acting as the \emph{Core}
\end{itemize}

\section{Renaming in a fully distributed setting}

\subsection{System Model}
\subsection{Intuition}
\subsection{Strategy to determine leading epoch in case of concurrency}
\subsection{Transitioning from a losing epoch to the leading one}
\subsection{Garbage collection}

\section{Evaluation}

\section{Discussion}

\subsection{Offloading on disk unused renaming rules}

\begin{itemize}
    \item As stated previously, nodes have to keep renamingMaps as long as another nodes may issue operations which would require to be transformed to be applied
    \item Thus nodes need to keep track of the progress of others to determine if such operations can still be issued or if it is safe to garbage collect the renaming rules
    \item In a fully distributed setting, this requirement is difficult to reach as nodes may join the collaboration, perform some operations and then disconnect
    \item Other nodes, from their point of view, are not able to determine if they disconnected temporarily or if it left definitely the collaboration
    \item However, as the disconnected nodes stopped progressing, they hold back the whole system and keep the current active nodes from garbage collecting old renaming rules
    \item To limit the impact of stale nodes on active ones, we propose that nodes offload unused renamingMaps by storing them on disk
\end{itemize}

\mnnote{Présenter une méthode pour déterminer les règles de renommage non-utilisées (conserver uniquement les règles utilisées pour traiter les $x$ dernières opérations ?)}

\subsection{Alternative strategy to determine leading epoch}
\subsection{Postponing transition between epochs in case of instability}

\begin{itemize}
    \item May reach a situation in which several nodes keep generating concurrent renaming operations on different epoch branches
    \item In such case, switching repeatedly between these concurrent branches may prove wasteful \mnnote{"costly" plutôt?}
    \item However, as long as nodes possess the required renamingMaps, they are able to rewrite operations from the other side and to integrate them into their copy, even if they are not on the latest epoch of their branch
    \begin{itemize}
        \item At the cost of an overhead per operation
    \end{itemize}
    \item Thus not moving to the new current epoch does not impede the liveness of the system
    \item Nodes can wait until one branch arise as the leading one then move to this epoch
    \item To speed up the emergence of such a branch, communications can be increased between nodes in such case to ease synchronisation
\end{itemize}

\subsection{Compressing the renaming operation}

\label{sec:optimisation-renamingMap}

\mnnote{TODO: Retravailler pour y ajouter la notion d'offset. Par contre, faire remarquer qu'on a pas besoin de l'offset pour identifier de manière unique "la base" d'une position (toute la position sauf l'offset)}

\begin{itemize}
    \item Propagating the renaming operation consists in broadcasting the list of blocks on which the renaming was performed, so that other nodes are able to compute the same rewriting rules
    \item This could prove costly, as the state before renaming can be composed of many blocks, each using long positions
    \item We propose an approach to compress this operation to reduce its bandwidth consumption at the cost of additional computations to process it
    \item Despite the variable length of positions, the parts required to identify an position uniquely are fixed
    \begin{itemize}
        \item We only need the $siteId$ and the $seq$ of the last tuple of the position to do so
    \end{itemize}
    \item Instead of broadcasting the list of whole positions, the node which performs the renaming can just broadcast the list of tuples $<siteId, seq>$
    \item On reception of a compressed renaming operation, a node needs first to regenerate the list of renamed blocks to be able to apply it
    \item To achieve so, it can browse its current state looking for positions with corresponding tuples $<siteId, seq>$
    \item If some positions are missing from the state, it means that they were deleted concurrently
    \item The node can thus browse the concurrent remove operations to the renaming one to find the missing blocks
    \item Once all positions has been retrieved and the list of blocks computed, the renaming operation can be processed normally
\end{itemize}

\subsection{Operational Transformation}

\mnnote{Ajouter une section sur OT pour expliquer que gérer les opérations concurrentes aux renommages consiste en finalité à transformer ces opérations, mais qu'on a décidé de ne pas présenter et formaliser l'approche comme étant de l'OT dans ce papier pour des raisons de simplicité ?}

\section{Conclusion}

\printbibliography

\end{document}
